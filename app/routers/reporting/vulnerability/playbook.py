# This file is part of Guardian.
#
# Guardian is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Guardian is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with MyAwesomeProject. If not, see <https://www.gnu.org/licenses/>.

from __future__ import annotations

import re
import logging
from uuid import UUID
from typing import Annotated, List, Dict, Optional
from sqlmodel import SQLModel
from fastapi import Body, Depends, APIRouter, Security, status
from sqlalchemy.orm import Session
from core.config import API_PREFIX
from schema import get_db
from schema.util import (
    ApiPermissionEnum, get_by_id, update_database_record, StatusMessage, StatusEnum, ProjectType, InvalidDataError,
    get_json_value, update_language_fields, NotFoundError
)
from schema.reporting.vulnerability.playbook import (
    Playbook, PlaybookRead, PlaybookCreate, PlaybookUpdate, PlaybookLookup, PlaybookLanguage
)
from schema.reporting.vulnerability.test_procedure import TestProcedure
from schema.reporting.report_language import ReportLanguage
from routers.user import User, get_current_active_user, get_logger

__author__ = "Lukas Reiter"
__copyright__ = "Copyright (C) 2024 Lukas Reiter"
__license__ = "GPLv3"

API_PLAYBOOKS_SUFFIX = "/playbooks"
API_PLAYBOOKS_PREFIX = API_PREFIX + API_PLAYBOOKS_SUFFIX
API_PENTEST_PLAYBOOKS_PREFIX = API_PLAYBOOKS_PREFIX + "/pentest"


router = APIRouter(
    prefix=API_PENTEST_PLAYBOOKS_PREFIX,
    tags=["playbooks"],
    responses={
        401: {"description": "Unauthorized"},
        400: {"description": "Incomplete or invalid data"},
        404: {"description": "Not found"},
        500: {"description": "Internal Server Error"}
    }
)


def post_process_multi_language_fields(
        session: Session,
        playbook: Playbook | None | SQLModel,
        **kwargs: Dict[str, str]
):
    """
    Process the language-specific details of a playbook.
    """
    # Define function that creates a new language details object.
    def create_object(parent_object: SQLModel, language: SQLModel, **kwargs: Dict[str, str]):
        return PlaybookLanguage(
            language=language,
            playbook=parent_object,
            **kwargs
        )
    # Create/update the language details table for the vulnerability template.
    update_language_fields(
        session=session,
        parent_object=playbook,
        create_object=create_object,
        **kwargs
    )


def make_unique_name(name: str) -> str:
    """
    This method makes a name unique by appending a number to it.
    """
    match = re.match(r"(.+?)_(\d+)?$", name)
    if match:
        name = match.group(1)
        number = int(match.group(2) or 0)
        number += 1
        return f"{name}_{number:02d}"
    else:
        return f"{name}_01"


def _build_playbook(session: Session, children: Dict, language: ReportLanguage) -> Dict:
    """
    Recursively builds a playbook that just contains the fields with the given language.
    """
    result = {}
    for item_key, item_value in children.items():
        node_type = get_json_value(item_value, "type")
        if node_type == "container":
            item_id = get_json_value(item_value, "id")
            title = get_json_value(item_value, "info/title/" + language.language_code)
            description = get_json_value(item_value, "info/description/" + language.language_code)
            if not item_id:
                raise ValueError(f"The playbook does not contain an ID for '{item_key}' in the requested "
                                 f"language {language.name}. Please complete the playbook.")
            if not title:
                raise ValueError(f"The playbook does not contain a title for '{item_key}' in the requested "
                                 f"language {language.name}. Please complete the playbook.")
            if not node_type:
                raise ValueError("The playbook is corrupted. It does not contain a type.")
            title = make_unique_name(title) if title in result else title
            result[title] = {
                "id": item_id,
                "title": title,
                "description": description if description else "",
                "type": node_type
            }
            result[title]["children"] = _build_playbook(session, item_value["children"], language)
        elif node_type == "procedure":
            procedure = session.query(TestProcedure).filter_by(id=item_value["id"]).one()
            title = make_unique_name(procedure.name) if procedure.name in result else procedure.name
            result[title] = {
                "id": procedure.id,
                "title": title,
                "type": node_type
            }
        else:
            raise ValueError(f"The playbook is corrupted. The node type '{node_type}' is not supported.")
    return result


def build_playbook(session: Session, source: Playbook, language: ReportLanguage) -> Dict:
    """
    Builds a playbook that just contains the fields with the given language.
    """
    return _build_playbook(session, source.structure, language)


def _get_template_procedure_ids(item) -> List[str]:
    """
    Recursively traverses all structure items and returns all procedure IDs.
    """
    result = []
    if "type" in item and item["type"] == "procedure":
        result.append(item["id"])
    elif "children" in item:
        for child in item["children"]:
            result += _get_template_procedure_ids(child)
    return result


def get_template_procedure_ids(structure: List) -> List[str]:
    """
    This method recursively obtains all template procedure IDs from the given playbook's structure.
    """
    result = []
    for item in structure:
        result += _get_template_procedure_ids(item)
    return result


def post_update(session: Session, playbook: Playbook, structure: List):
    """
    Updates relationships between the given playbook and Template Procedures after creation/update of the given
    playbook.
    """
    procedure_ids = get_template_procedure_ids(structure)
    playbook.procedures = session.query(TestProcedure).filter(TestProcedure.id.in_(procedure_ids)).all()


def check_playbook(playbook: PlaybookCreate):
    """
    Checks if the given playbook is valid.
    """
    # TODO: Implement test playbook checks
    pass


def get_playbook_by_id(playbook_id: UUID, session: Annotated[Session, Depends(get_db)]) -> SQLModel:
    """
    Get a playbook by its ID.
    """
    return get_by_id(session, Playbook, playbook_id)


def get_playbooks(session: Session, project_type: ProjectType) -> List[Playbook]:
    """
    Method returns all measures for specific project types.
    """
    return (session.query(Playbook)
            .filter(Playbook.project_type == project_type)
            .order_by(Playbook.name).all())


@router.get("", response_model=List[PlaybookRead])
def read_pentest_playbooks(
    _: Annotated[User, Security(get_current_active_user, scopes=[ApiPermissionEnum.pentest_playbook_read.name])],
    session: Annotated[Session, Depends(get_db)]
):
    """
    Returns all penetration testing playbooks.
    """
    result = get_playbooks(session, ProjectType.penetration_test)
    return result


@router.get("/lookup", response_model=List[PlaybookLookup])
def read_pentest_playbooks(
    _: Annotated[User, Security(get_current_active_user, scopes=[ApiPermissionEnum.pentest_playbook_read.name])],
    session: Annotated[Session, Depends(get_db)]
):
    """
    Returns summary for all penetration testing playbooks.
    """
    result = get_playbooks(session, ProjectType.penetration_test)
    return result


@router.get("/{playbook_id}", response_model=Optional[PlaybookRead])
def read_playbooks(
    _: Annotated[User, Security(get_current_active_user, scopes=[ApiPermissionEnum.pentest_playbook_read.name])],
    playbook: Annotated[UUID, Depends(get_playbook_by_id)],
    session: Annotated[Session, Depends(get_db)],
    language: Optional[str] = None,
):
    """
    Returns a penetration testing playbook by its ID.
    """
    if language:
        lang = session.query(ReportLanguage).filter_by(language_code=language).one_or_none()
        if not lang:
            return
        structure = build_playbook(session, playbook, lang)
        return Playbook(id=playbook.id, name=playbook.name, structure=structure)
    return


@router.delete("/{playbook_id}", response_model=StatusMessage)
def delete_playbook(
    _: Annotated[User, Security(get_current_active_user, scopes=[ApiPermissionEnum.pentest_playbook_delete.name])],
    playbook: Annotated[UUID, Depends(get_playbook_by_id)],
    session: Session = Depends(get_db)
):
    """
    Deletes a penetration testing playbook.
    """
    session.delete(playbook)
    session.commit()
    return StatusMessage(
        status=status.HTTP_200_OK,
        severity=StatusEnum.success,
        message=f"Record successfully deleted."
    )


@router.post("", response_model=PlaybookRead)
def create_playbook(
    _: Annotated[User, Security(get_current_active_user, scopes=[ApiPermissionEnum.pentest_playbook_create.name])],
    playbook: Annotated[PlaybookCreate, Body],
    session: Session = Depends(get_db)
):
    """
    Creates a penetration testing playbook.
    """
    try:
        check_playbook(playbook)
        # Create the playbook
        result = Playbook(**playbook.model_dump(), project_type=ProjectType.penetration_test)
        session.add(result)
        # Create the language-specific details of the vulnerability template
        post_process_multi_language_fields(
            session,
            result,
            title=playbook.title,
            description=playbook.description
        )
        # Here we create the relationship between the new playbook and all Template Procedures mentioned in the
        # structure dictionary.
        post_update(session, result, playbook.structure)
        session.commit()
        session.refresh(result)
        return result
    except Exception as e:
        raise InvalidDataError(str(e))


@router.put("", response_model=PlaybookRead)
def update_playbook(
    _: Annotated[User, Security(get_current_active_user, scopes=[ApiPermissionEnum.pentest_playbook_update.name])],
    logger: Annotated[logging.Logger, Depends(get_logger)],
    item: Annotated[PlaybookUpdate, Body],
    session: Session = Depends(get_db)
):
    """
    Updates a penetration testing playbook.
    """
    try:
        result = update_database_record(
            session=session,
            source=item,
            source_model=PlaybookUpdate,
            query_model=Playbook,
            commit=False
        )
        # Update the language-specific details of the measure
        post_process_multi_language_fields(
            session,
            result,
            title=item.title,
            description=item.description
        )
        # Here we create the relationship between the new playbook and all Template Procedures mentioned in the
        # structure dictionary.
        post_update(session, result, item.structure)
        session.commit()
        session.refresh(result)
        return result
    except NotFoundError as e:
        logger.exception(e)
        return item
    except Exception as e:
        raise InvalidDataError(str(e))
