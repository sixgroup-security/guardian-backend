# This file is part of Guardian.
#
# Guardian is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Guardian is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Guardian. If not, see <https://www.gnu.org/licenses/>.

from __future__ import annotations

import logging
from uuid import UUID
from typing import Annotated, Dict, Union, List
from sqlmodel import SQLModel
from fastapi import Body, Depends, APIRouter, Security, status
from sqlalchemy import and_
from sqlalchemy.orm import Session
from core.config import API_PREFIX
from schema import get_db
from schema.util import (
    ApiPermissionEnum, get_all, get_by_id, update_database_record, StatusMessage, StatusEnum,
    InvalidDataError, update_language_fields, NotFoundError
)
from schema.tagging import Tag, TagCategoryEnum
from schema.reporting.vulnerability.measure import Measure
from schema.reporting.vulnerability.vulnerability_template import (
    VulnerabilityTemplate, VulnerabilityTemplateCreate, VulnerabilityTemplateLanguage, VulnerabilityTemplateRead,
    VulnerabilityTemplateUpdate
)
from routers.user import User, get_current_active_user, get_logger

__author__ = "Lukas Reiter"
__copyright__ = "Copyright (C) 2024 Lukas Reiter"
__license__ = "GPLv3"

API_VULNERABILITY_TEMPLATE_SUFFIX = "/vulnerability-templates"
API_VULNERABILITY_TEMPLATE_PREFIX = API_PREFIX + API_VULNERABILITY_TEMPLATE_SUFFIX


router = APIRouter(
    prefix=API_VULNERABILITY_TEMPLATE_PREFIX,
    tags=["vulnerability template"],
    responses={
        401: {"description": "Unauthorized"},
        400: {"description": "Incomplete or invalid data"},
        404: {"description": "Not found"},
        500: {"description": "Internal Server Error"}
    }
)


def post_process_multi_language_fields(
        session: Session,
        vulnerability: Union[VulnerabilityTemplate | SQLModel],
        **kwargs: Dict[str, str]
):
    """
    Process the language-specific details of a vulnerability template.
    """
    # Define function that creates a new language details object.
    def create_object(parent_object: SQLModel, language: SQLModel, **kwargs: Dict[str, str]):
        return VulnerabilityTemplateLanguage(
            language=language,
            vulnerability=parent_object,
            **kwargs
        )
    # Create/update the language details table for the vulnerability template.
    update_language_fields(
        session=session,
        parent_object=vulnerability,
        create_object=create_object,
        **kwargs
    )


def check_vulnerability_template(template: Union[VulnerabilityTemplateCreate, VulnerabilityTemplateUpdate]):
    """
    Checks if the given vulnerability template is valid.
    """
    if template.title is None or len(template.title) == 0:
        raise InvalidDataError("Title is required.")
    if template.description is None or len(template.description) == 0:
        raise InvalidDataError("Description is required.")


def get_vulnerability_template(template_id: UUID, session: Annotated[Session, Depends(get_db)]) -> SQLModel:
    """
    Get a vulnerability template by its ID.
    """
    return get_by_id(session, VulnerabilityTemplate, template_id)


def add_tags(
        session: Session,
        vulnerability_template: VulnerabilityTemplate | VulnerabilityTemplateUpdate,
        general_tags: List[UUID]
):
    """
    Updates the tags of the given vulnerability template.
    """
    vulnerability_template.general_tags = session.query(Tag) \
        .filter(and_(Tag.id.in_(general_tags),
                     Tag.categories.contains([TagCategoryEnum.vulnerability_template, TagCategoryEnum.general]))).all()


@router.get("", response_model=List[VulnerabilityTemplateRead])
def read_vulnerability_template(
    _: Annotated[User, Security(
        get_current_active_user,
        scopes=[ApiPermissionEnum.pentest_report_read.name, ApiPermissionEnum.vulnerability_template_read.name]
    )],
    session: Annotated[Session, Depends(get_db)]
):
    """
    Returns all vulnerability templates.
    """
    result = get_all(session, VulnerabilityTemplate).all()
    return result


@router.delete("/{template_id}", response_model=StatusMessage)
def delete_vulnerability_template(
    _: Annotated[User, Security(
        get_current_active_user,
        scopes=[ApiPermissionEnum.vulnerability_template_delete.name]
    )],
    template_procedure: Annotated[UUID, Depends(get_vulnerability_template)],
    session: Session = Depends(get_db)
):
    """
    Deletes a vulnerability template by its ID.
    """
    session.delete(template_procedure)
    session.commit()
    return StatusMessage(
        status=status.HTTP_200_OK,
        severity=StatusEnum.success,
        message=f"Record successfully deleted."
    )


@router.post("", response_model=VulnerabilityTemplateRead)
def create_vulnerability_template(
    _: Annotated[User, Security(
        get_current_active_user,
        scopes=[ApiPermissionEnum.vulnerability_template_create.name]
    )],
    template: Annotated[VulnerabilityTemplateCreate, Body],
    session: Session = Depends(get_db)
):
    """
    Creates a new vulnerability template.
    """
    try:
        check_vulnerability_template(template)
        # Create the vulnerability template
        result = VulnerabilityTemplate(**template.model_dump(exclude={"general_tags"}))
        session.add(result)
        # Create the language-specific details of the vulnerability template
        post_process_multi_language_fields(
            session,
            result,
            title=template.title,
            description=template.description,
            observation=template.observation
        )
        # Create measures
        for measure_id in template.measure_ids:
            measure = get_by_id(session, Measure, measure_id)
            result.measures.append(measure)
        # Assign tags
        add_tags(
            session=session,
            vulnerability_template=result,
            general_tags=template.general_tags
        )
        session.commit()
        session.refresh(result)
        return result
    except Exception as e:
        raise InvalidDataError(str(e))


@router.put("", response_model=VulnerabilityTemplateRead)
def update_vulnerability_template(
    _: Annotated[User, Security(
        get_current_active_user,
        scopes=[ApiPermissionEnum.vulnerability_template_update.name]
    )],
    logger: Annotated[logging.Logger, Depends(get_logger)],
    item: Annotated[VulnerabilityTemplateUpdate, Body],
    session: Session = Depends(get_db)
):
    """
    Updates a template procedure.
    """
    try:
        check_vulnerability_template(item)
        # Update the template procedure
        result = update_database_record(
            session=session,
            source=item,
            source_model=VulnerabilityTemplateUpdate,
            query_model=VulnerabilityTemplate,
            exclude={"general_tags"},
            commit=False
        )
        # Update the language-specific details of the measure
        post_process_multi_language_fields(
            session,
            result,
            title=item.title,
            description=item.description,
            observation=item.observation
        )
        result.measures = session.query(Measure).filter(Measure.id.in_(item.measure_ids)).all()
        # Assign tags
        add_tags(
            session=session,
            vulnerability_template=result,
            general_tags=item.general_tags
        )
        session.commit()
        session.refresh(result)
        return result
    except NotFoundError as e:
        logger.exception(e)
        return item
    except Exception as e:
        raise InvalidDataError(str(e))
