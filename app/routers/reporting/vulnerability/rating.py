# This file is part of Guardian.
#
# Guardian is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Guardian is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with MyAwesomeProject. If not, see <https://www.gnu.org/licenses/>.

from __future__ import annotations

import logging
from uuid import UUID
from typing import Annotated, Union, Dict, List
from sqlmodel import SQLModel
from fastapi import Body, Depends, APIRouter, Security, status
from sqlalchemy.orm import Session
from schema import get_db
from schema.util import (
    ApiPermissionEnum, update_database_record, StatusMessage, StatusEnum, InvalidDataError, update_language_fields,
    NotFoundError
)
from schema.reporting.vulnerability.vulnerability_template import VulnerabilityTemplate
from schema.reporting.vulnerability.rating import Rating, RatingCreate, RatingRead, RatingUpdate, RatingLanguage
from routers.reporting.vulnerability.vulnerability_template import (
    API_VULNERABILITY_TEMPLATE_PREFIX, get_vulnerability_template
)
from routers.user import User, get_current_active_user, get_logger

__author__ = "Lukas Reiter"
__copyright__ = "Copyright (C) 2024 Lukas Reiter"
__license__ = "GPLv3"

API_RATING_SUFFIX = "/ratings"
API_RATING_PREFIX = API_VULNERABILITY_TEMPLATE_PREFIX + "/{template_id}" + API_RATING_SUFFIX


router = APIRouter(
    prefix=API_RATING_PREFIX,
    tags=["rating"],
    responses={
        401: {"description": "Unauthorized"},
        400: {"description": "Incomplete or invalid data"},
        404: {"description": "Not found"},
        500: {"description": "Internal Server Error"}
    }
)


def post_process_rating_language(
        session: Session,
        rating: SQLModel,
        **kwargs: Dict[str, str]
):
    """
    Process the language-specific details of a rating.
    """
    # Define function that creates a new language details object.
    def create_object(parent_object: SQLModel, language: SQLModel, **kwargs: Dict[str, str]):
        return RatingLanguage(
            language=language,
            rating=parent_object,
            **kwargs
        )
    # Create/update the language details table for the template procedure.
    update_language_fields(
        session=session,
        parent_object=rating,
        create_object=create_object,
        **kwargs
    )


def get_rating_by_id(session: Annotated[Session, Depends(get_db)], template_id: UUID, rating_id: UUID) -> SQLModel:
    """
    Get an object of class model by its ID from the database.
    """
    result = (
        session.query(Rating).join(VulnerabilityTemplate)
              .filter(VulnerabilityTemplate.id == template_id)
              .filter(Rating.id == rating_id).first()
    )
    if not result:
        raise NotFoundError(f"Rating with ID {rating_id} not found.")
    return result


def check_rating(rating: Union[RatingCreate | RatingUpdate]):
    """
    Checks if the given rating is valid.
    """
    if rating.comment is None or len(rating.comment) == 0:
        raise InvalidDataError("Comment is required.")


@router.get("", response_model=List[RatingRead])
def read_rating(
    _: Annotated[User, Security(
        get_current_active_user,
        scopes=[
            ApiPermissionEnum.pentest_report_read.name,
            ApiPermissionEnum.vulnerability_template_read.name
        ]
    )],
    procedure: Annotated[UUID, Depends(get_vulnerability_template)],
    session: Annotated[Session, Depends(get_db)]
):
    """
    Returns all ratings associated with the given vulnerability template ID.
    """
    # Read content
    items = session.query(Rating) \
        .join(VulnerabilityTemplate, Rating.vulnerability_template) \
        .filter(VulnerabilityTemplate.id == procedure.id) \
        .order_by(Rating.name).all()
    return items


@router.delete("/{rating_id}", response_model=StatusMessage)
def delete_rating(
    _: Annotated[User, Security(get_current_active_user, scopes=[ApiPermissionEnum.vulnerability_template_update.name])],
    rating: Rating = Depends(get_rating_by_id),
    session: Session = Depends(get_db)
):
    """
    Deletes a rating by its ID from the given vulnerability template.
    """
    session.delete(rating)
    session.commit()
    return StatusMessage(
        status=status.HTTP_200_OK,
        severity=StatusEnum.success,
        message=f"Record successfully deleted."
    )


@router.post("", response_model=RatingRead)
def create_rating(
    _: Annotated[User, Security(get_current_active_user, scopes=[ApiPermissionEnum.vulnerability_template_update.name])],
    template_id: UUID,
    rating: Annotated[RatingCreate, Body],
    session: Session = Depends(get_db)
):
    """
    Creates a new rating and associates it with the given template ID.
    """
    try:
        check_rating(rating)
        # Create the rating
        result = Rating(**rating.model_dump(), vulnerability_id=template_id)
        session.add(result)
        # Create the language-specific details of the measure
        post_process_rating_language(session, result, comment=rating.comment)
        session.commit()
        session.refresh(result)
        return result
    except Exception as e:
        raise InvalidDataError(str(e))


@router.put("", response_model=RatingRead)
def update_rating(
    _: Annotated[User, Security(get_current_active_user, scopes=[ApiPermissionEnum.vulnerability_template_update.name])],
    logger: Annotated[logging.Logger, Depends(get_logger)],
    item: Annotated[RatingUpdate, Body],
    session: Session = Depends(get_db)
):
    """
    Updates an existing rating.
    """
    try:
        check_rating(item)
        # Update the rating
        result = update_database_record(
            session=session,
            source=item,
            source_model=RatingUpdate,
            query_model=Rating,
            commit=False
        )
        # Update the language-specific details of the rating
        post_process_rating_language(session, result, comment=item.comment)
        session.commit()
        session.refresh(result)
        return result
    except NotFoundError as e:
        logger.exception(e)
        return item
    except Exception as e:
        raise InvalidDataError(str(e))
